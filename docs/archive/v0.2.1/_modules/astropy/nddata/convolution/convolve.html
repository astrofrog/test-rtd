
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    

    <title>astropy.nddata.convolution.convolve &mdash; Astropy v0.2.1</title>
<!-- RTD <head> -->
<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript" src="//media.readthedocs.org/javascript/underscore.js"></script>
<script type="text/javascript" src="//media.readthedocs.org/javascript/doctools.js"></script>

<script type="text/javascript">
  // This is included here for Javascript that doesn't have access to the templates.
  var doc_version = "v0.2.1";
  var doc_slug = "astropy";
</script>

<script type="text/javascript" src="//media.readthedocs.org/javascript/rtd.js"></script>
<!-- end RTD <head> -->

    
    <link rel="stylesheet" href="../../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../../_static/astropy_logo.ico"/>
    <link rel="top" title="Astropy v0.2.1" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../index.html"></a>
  <ul>
    <li><a class="homelink" title="AstroPy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../../genindex.html">Index</a></li>
    <li><a title="Python Module Index" href="../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../index.html">Astropy v0.2.1</a>
	 &raquo;
      </li>
      <li><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for astropy.nddata.convolution.convolve</h1><div class="highlight"><pre>
<span class="c"># Licensed under a 3-clause BSD style license - see PYFITS.rst</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">...config</span> <span class="kn">import</span> <span class="n">ConfigurationItem</span>
<span class="kn">from</span> <span class="nn">...</span> <span class="kn">import</span> <span class="n">log</span>

<div class="viewcode-block" id="convolve"><a class="viewcode-back" href="../../../../_generated/astropy.nddata.convolution.convolve.convolve.html#astropy.nddata.convolution.convolve.convolve">[docs]</a><span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
             <span class="n">normalize_kernel</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Convolve an array with a kernel.</span>

<span class="sd">    This routine differs from `scipy.ndimage.filters.convolve` because</span>
<span class="sd">    it includes a special treatment for `NaN` values. Rather than</span>
<span class="sd">    including `NaNs` in the convolution calculation, which causes large</span>
<span class="sd">    `NaN` holes in the convolved image, `NaN` values are replaced with</span>
<span class="sd">    interpolated values using the kernel as an interpolation function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : `numpy.ndarray`</span>
<span class="sd">        The array to convolve. This should be a 1, 2, or 3-dimensional array</span>
<span class="sd">        or a list or a set of nested lists representing a 1, 2, or</span>
<span class="sd">        3-dimensional array.</span>
<span class="sd">    kernel : `numpy.ndarray`</span>
<span class="sd">        The convolution kernel. The number of dimensions should match those</span>
<span class="sd">        for the array, and the dimensions should be odd in all directions.</span>
<span class="sd">    boundary : str, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>
<span class="sd">            * `None`</span>
<span class="sd">                Set the `result` values to zero where the kernel</span>
<span class="sd">                extends beyond the edge of the array (default).</span>
<span class="sd">            * &#39;fill&#39;</span>
<span class="sd">                Set values outside the array boundary to `fill_value`.</span>
<span class="sd">            * &#39;wrap&#39;</span>
<span class="sd">                Periodic boundary that wrap to the other side of `array`.</span>
<span class="sd">            * &#39;extend&#39;</span>
<span class="sd">                Set values outside the array to the nearest `array`</span>
<span class="sd">                value.</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        The value to use outside the array when using boundary=&#39;fill&#39;</span>
<span class="sd">    normalize_kernel : bool, optional</span>
<span class="sd">        Whether to normalize the kernel prior to convolving</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : `numpy.ndarray`</span>
<span class="sd">        An array with the same dimensions and type as the input array,</span>
<span class="sd">        convolved with kernel.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Masked arrays are not supported at this time.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">.boundary_none</span> <span class="kn">import</span> <span class="n">convolve1d_boundary_none</span><span class="p">,</span> \
                               <span class="n">convolve2d_boundary_none</span><span class="p">,</span> \
                               <span class="n">convolve3d_boundary_none</span>

    <span class="kn">from</span> <span class="nn">.boundary_extend</span> <span class="kn">import</span> <span class="n">convolve1d_boundary_extend</span><span class="p">,</span> \
                                 <span class="n">convolve2d_boundary_extend</span><span class="p">,</span> \
                                 <span class="n">convolve3d_boundary_extend</span>

    <span class="kn">from</span> <span class="nn">.boundary_fill</span> <span class="kn">import</span> <span class="n">convolve1d_boundary_fill</span><span class="p">,</span> \
                               <span class="n">convolve2d_boundary_fill</span><span class="p">,</span> \
                               <span class="n">convolve3d_boundary_fill</span>

    <span class="kn">from</span> <span class="nn">.boundary_wrap</span> <span class="kn">import</span> <span class="n">convolve1d_boundary_wrap</span><span class="p">,</span> \
                               <span class="n">convolve2d_boundary_wrap</span><span class="p">,</span> \
                               <span class="n">convolve3d_boundary_wrap</span>

    <span class="c"># Check that the arguemnts are lists or Numpy arrays</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;array should be a list or a Numpy array&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;kernel should be a list or a Numpy array&quot;</span><span class="p">)</span>

    <span class="c"># Check that the number of dimensions is compatible</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;array and kernel have differing number of&#39;</span>
                        <span class="s">&#39;dimensions&#39;</span><span class="p">)</span>

    <span class="c"># The .dtype.type attribute returs the datatype without the endian. We can</span>
    <span class="c"># use this to check that the arrays are 32- or 64-bit arrays</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;i&#39;</span><span class="p">:</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s">&#39;f&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;array should be an integer or a &#39;</span>
                        <span class="s">&#39;floating-point Numpy array&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kernel</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;i&#39;</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kernel</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s">&#39;f&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;kernel should be an integer or a &#39;</span>
                        <span class="s">&#39;floating-point Numpy array&#39;</span><span class="p">)</span>

    <span class="c"># Because the Cython routines have to normalize the kernel on the fly, we</span>
    <span class="c"># explicitly normalize the kernel here, and then scale the image at the</span>
    <span class="c"># end if normalization was not requested.</span>
    <span class="n">kernel_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">/=</span> <span class="n">kernel_sum</span>

    <span class="c"># The cython routines are written for np.float, but the default endian</span>
    <span class="c"># depends on platform. For that reason, we first save the original</span>
    <span class="c"># array datatype, cast to np.float, then convert back</span>
    <span class="n">array_dtype</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span>

    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;cannot convolve 0-dimensional arrays&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;extend&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve1d_boundary_extend</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                                <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;fill&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve1d_boundary_fill</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                              <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                              <span class="nb">float</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;wrap&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve1d_boundary_wrap</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                              <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve1d_boundary_none</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                              <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;extend&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve2d_boundary_extend</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                                <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;fill&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve2d_boundary_fill</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                              <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                              <span class="nb">float</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;wrap&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve2d_boundary_wrap</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                              <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve2d_boundary_none</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                              <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;extend&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve3d_boundary_extend</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                                <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;fill&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve3d_boundary_fill</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                              <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                              <span class="nb">float</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;wrap&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve3d_boundary_wrap</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                              <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve3d_boundary_none</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                                              <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">(</span><span class="s">&#39;convolve only supports 1, 2, and 3-dimensional &#39;</span>
                             <span class="s">&#39;arrays at this time&#39;</span><span class="p">)</span>

    <span class="c"># If normalization was not requested, we need to scale the array (since</span>
    <span class="c"># the kernel was normalized prior to convolution)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">normalize_kernel</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="n">kernel_sum</span>

    <span class="c"># Cast back to original dtype and return</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">array_dtype</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="convolve_fft"><a class="viewcode-back" href="../../../../_generated/astropy.nddata.convolution.convolve.convolve_fft.html#astropy.nddata.convolution.convolve.convolve_fft">[docs]</a><span class="k">def</span> <span class="nf">convolve_fft</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s">&#39;fill&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">return_fft</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">fft_pad</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">psf_pad</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">interpolate_nan</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ignore_edge_zeros</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">min_wt</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">normalize_kernel</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">fftn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">,</span>
                 <span class="n">ifftn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">,</span> <span class="n">complex_dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve an ndarray with an nd-kernel.  Returns a convolved image with</span>
<span class="sd">    shape = array.shape.  Assumes kernel is centered.</span>

<span class="sd">    `convolve_fft` differs from `scipy.signal.fftconvolve` in a few ways:</span>

<span class="sd">    * It can treat NaN&#39;s as zeros or interpolate over them.</span>
<span class="sd">    * `inf` values are treated as `NaN`</span>
<span class="sd">    * (optionally) It pads to the nearest 2^n size to improve FFT speed.</span>
<span class="sd">    * Its only valid `mode` is &#39;same&#39; (i.e., the same shape array is returned)</span>
<span class="sd">    * It lets you use your own fft, e.g.,</span>
<span class="sd">      `pyFFTW &lt;http://pypi.python.org/pypi/pyFFTW&gt;`_ or</span>
<span class="sd">      `pyFFTW3 &lt;http://pypi.python.org/pypi/PyFFTW3/0.2.1&gt;`_ , which can lead to</span>
<span class="sd">      performance improvements, depending on your system configuration.  pyFFTW3</span>
<span class="sd">      is threaded, and therefore may yield significant performance benefits on</span>
<span class="sd">      multi-core machines at the cost of greater memory requirements.  Specify</span>
<span class="sd">      the `fftn` and `ifftn` keywords to override the default, which is</span>
<span class="sd">      `numpy.fft.fft` and `numpy.fft.ifft`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : `numpy.ndarray`</span>
<span class="sd">          Array to be convolved with `kernel`</span>
<span class="sd">    kernel : `numpy.ndarray`</span>
<span class="sd">          Will be normalized if `normalize_kernel` is set.  Assumed to be</span>
<span class="sd">          centered (i.e., shifts may result if your kernel is asymmetric)</span>
<span class="sd">    boundary : {&#39;fill&#39;, &#39;wrap&#39;}</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>

<span class="sd">            * &#39;fill&#39;: set values outside the array boundary to fill_value</span>
<span class="sd">              (default)</span>
<span class="sd">            * &#39;wrap&#39;: periodic boundary</span>

<span class="sd">    interpolate_nan : bool</span>
<span class="sd">        The convolution will be re-weighted assuming NAN values are meant to be</span>
<span class="sd">        ignored, not treated as zero.  If this is off, all NaN values will be</span>
<span class="sd">        treated as zero.</span>
<span class="sd">    ignore_edge_zeros : bool</span>
<span class="sd">        Ignore the zero-pad-created zeros.  This will effectively decrease</span>
<span class="sd">        the kernel area on the edges but will not re-normalize the kernel.</span>
<span class="sd">        This parameter may result in &#39;edge-brightening&#39; effects if you&#39;re using</span>
<span class="sd">        a normalized kernel</span>
<span class="sd">    min_wt : float</span>
<span class="sd">        If ignoring NANs/zeros, force all grid points with a weight less than</span>
<span class="sd">        this value to NAN (the weight of a grid point with *no* ignored</span>
<span class="sd">        neighbors is 1.0).</span>
<span class="sd">        If `min_wt` == 0.0, then all zero-weight points will be set to zero</span>
<span class="sd">        instead of NAN (which they would be otherwise, because 1/0 = nan).</span>
<span class="sd">        See the examples below</span>
<span class="sd">    normalize_kernel : function or boolean</span>
<span class="sd">        If specified, this is the function to divide kernel by to normalize it.</span>
<span class="sd">        e.g., normalize_kernel=np.sum means that kernel will be modified to be:</span>
<span class="sd">        kernel = kernel / np.sum(kernel).  If True, defaults to</span>
<span class="sd">        normalize_kernel = np.sum</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    fft_pad : bool</span>
<span class="sd">        Default on.  Zero-pad image to the nearest 2^n</span>
<span class="sd">    psf_pad : bool</span>
<span class="sd">        Default off.  Zero-pad image to be at least the sum of the image sizes</span>
<span class="sd">        (in order to avoid edge-wrapping when smoothing)</span>
<span class="sd">    crop : bool</span>
<span class="sd">        Default on.  Return an image of the size of the largest input image.</span>
<span class="sd">        If the images are asymmetric in opposite directions, will return the</span>
<span class="sd">        largest image in both directions.</span>
<span class="sd">        For example, if an input image has shape [100,3] but a kernel with shape</span>
<span class="sd">        [6,6] is used, the output will be [100,6].</span>
<span class="sd">    return_fft : bool</span>
<span class="sd">        Return the fft(image)*fft(kernel) instead of the convolution (which is</span>
<span class="sd">        ifft(fft(image)*fft(kernel))).  Useful for making PSDs.</span>
<span class="sd">    nthreads : int</span>
<span class="sd">        if fftw3 is installed, can specify the number of threads to allow FFTs</span>
<span class="sd">        to use.  Probably only helpful for large arrays</span>
<span class="sd">    fftn, ifftn : functions</span>
<span class="sd">        The fft and inverse fft functions.  Can be overridden to use your own</span>
<span class="sd">        ffts, e.g. an fftw3 wrapper or scipy&#39;s fftn, e.g.</span>
<span class="sd">        `fftn=scipy.fftpack.fftn`</span>
<span class="sd">    complex_dtype : np.complex</span>
<span class="sd">        Which complex dtype to use.  `numpy` has a range of options, from 64 to</span>
<span class="sd">        256.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    convolve : Convolve is a non-fft version of this code.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    default : ndarray</span>
<span class="sd">        **array** convolved with `kernel`.</span>
<span class="sd">        If `return_fft` is set, returns fft(**array**) * fft(`kernel`).</span>
<span class="sd">        If crop is not set, returns the image, but with the fft-padded size</span>
<span class="sd">        instead of the input size</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; convolve_fft([1, 0, 3], [1, 1, 1])</span>
<span class="sd">    array([ 1.,  4.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1])</span>
<span class="sd">    array([ 1.,  4.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, 0, 3], [0, 1, 0])</span>
<span class="sd">    array([ 1.,  0.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, 2, 3], [1])</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [0, 1, 0], interpolate_nan=True)</span>
<span class="sd">    array([ 1.,  0.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [0, 1, 0], interpolate_nan=True,</span>
<span class="sd">    ...              min_wt=1e-8)</span>
<span class="sd">    array([ 1.,  nan,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], interpolate_nan=True)</span>
<span class="sd">    array([ 1.,  4.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], interpolate_nan=True,</span>
<span class="sd">    ...               normalize_kernel=True, ignore_edge_zeros=True)</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; import scipy.fftpack  # optional - requires scipy</span>
<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], interpolate_nan=True,</span>
<span class="sd">    ...               normalize_kernel=True, ignore_edge_zeros=True,</span>
<span class="sd">    ...               fftn=scipy.fftpack.fft, ifftn=scipy.fftpack.ifft)</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Checking copied from convolve.py - however, since FFTs have real &amp;</span>
    <span class="c"># complex components, we change the types.  Only the real part will be</span>
    <span class="c"># returned!</span>
    <span class="c"># Check that the arguments are lists or Numpy arrays</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>

    <span class="c"># Check that the number of dimensions is compatible</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;array and kernel have differing number of&#39;</span>
                        <span class="s">&#39;dimensions&#39;</span><span class="p">)</span>

    <span class="c"># turn the arrays into &#39;complex&#39; arrays</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s">&#39;c&#39;</span><span class="p">:</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kernel</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s">&#39;c&#39;</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>

    <span class="c"># mask catching - masks must be turned into NaNs for use later</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">array</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">kernel</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
        <span class="n">kernel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c"># NAN and inf catching</span>
    <span class="n">nanmaskarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">array</span><span class="p">[</span><span class="n">nanmaskarray</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nanmaskkernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">kernel</span><span class="p">[</span><span class="n">nanmaskkernel</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">nanmaskarray</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nanmaskkernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">interpolate_nan</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;NOT ignoring nan values even though they are present&quot;</span> <span class="o">+</span>
                <span class="s">&quot; (they are treated as 0)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize_kernel</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">kernel_is_normalized</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">normalize_kernel</span><span class="p">:</span>
        <span class="c"># try this.  If a function is not passed, the code will just crash... I</span>
        <span class="c"># think type checking would be better but PEPs say otherwise...</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="n">normalize_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
        <span class="n">kernel_is_normalized</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
            <span class="n">kernel_is_normalized</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kernel_is_normalized</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">interpolate_nan</span> <span class="ow">or</span> <span class="n">ignore_edge_zeros</span><span class="p">):</span>
                <span class="n">WARNING</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;Kernel is not normalized, therefore ignore_edge_zeros&quot;</span><span class="o">+</span>
                    <span class="s">&quot;and interpolate_nan will be ignored.&quot;</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">WARNING</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">boundary</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">WARNING</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;The convolve_fft version of boundary=None is equivalent&quot;</span> <span class="o">+</span>
                <span class="s">&quot; to the convolve boundary=&#39;fill&#39;.  There is no FFT &quot;</span> <span class="o">+</span>
                <span class="s">&quot; equivalent to convolve&#39;s zero-if-kernel-leaves-boundary&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">WARNING</span><span class="p">)</span>
        <span class="n">psf_pad</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;fill&#39;</span><span class="p">:</span>
        <span class="c"># create a boundary region at least as large as the kernel</span>
        <span class="n">psf_pad</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;wrap&#39;</span><span class="p">:</span>
        <span class="n">psf_pad</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">fft_pad</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># force zero; it should not be used</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;extend&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;The &#39;extend&#39; option is not implemented &quot;</span> <span class="o">+</span>
                <span class="s">&quot;for fft-based convolution&quot;</span><span class="p">)</span>

    <span class="n">arrayshape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">kernshape</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Image and kernel must &quot;</span> <span class="o">+</span>
            <span class="s">&quot;have same number of dimensions&quot;</span><span class="p">)</span>
    <span class="c"># find ideal size (power of 2) for fft.</span>
    <span class="c"># Can add shapes because they are tuples</span>
    <span class="k">if</span> <span class="n">fft_pad</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">psf_pad</span><span class="p">:</span>
            <span class="c"># add the dimensions and then take the max (bigger)</span>
            <span class="n">fsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernshape</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># add the shape lists (max of a list of length 4) (smaller)</span>
            <span class="c"># also makes the shapes square</span>
            <span class="n">fsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">arrayshape</span> <span class="o">+</span> <span class="n">kernshape</span><span class="p">)))</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fsize</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">psf_pad</span><span class="p">:</span>
            <span class="c"># just add the biggest dimensions</span>
            <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernshape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">imsh</span><span class="p">,</span> <span class="n">kernsh</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">imsh</span><span class="p">,</span> <span class="n">kernsh</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">,</span> <span class="n">kernshape</span><span class="p">)])</span>

    <span class="c"># separate each dimension by the padding size...  this is to determine the</span>
    <span class="c"># appropriate slice size to get back to the input dimensions</span>
    <span class="n">arrayslices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernslices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">newdimsize</span><span class="p">,</span> <span class="n">arraydimsize</span><span class="p">,</span> <span class="n">kerndimsize</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arrayshape</span><span class="p">,</span> <span class="n">kernshape</span><span class="p">)):</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">newdimsize</span> <span class="o">-</span> <span class="p">(</span><span class="n">newdimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">arrayslices</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">arraydimsize</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">center</span> <span class="o">+</span> <span class="p">(</span><span class="n">arraydimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">kernslices</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">kerndimsize</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">center</span> <span class="o">+</span> <span class="p">(</span><span class="n">kerndimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="n">bigarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">fill_value</span>
    <span class="n">bigkernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
    <span class="n">bigarray</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>
    <span class="n">bigkernel</span><span class="p">[</span><span class="n">kernslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernel</span>
    <span class="n">arrayfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">bigarray</span><span class="p">)</span>
    <span class="c"># need to shift the kernel so that, e.g., [0,0,1,0] -&gt; [1,0,0,0] = unity</span>
    <span class="n">kernfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">bigkernel</span><span class="p">))</span>
    <span class="n">fftmult</span> <span class="o">=</span> <span class="n">arrayfft</span> <span class="o">*</span> <span class="n">kernfft</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">interpolate_nan</span> <span class="ow">or</span> <span class="n">ignore_edge_zeros</span><span class="p">)</span> <span class="ow">and</span> <span class="n">kernel_is_normalized</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ignore_edge_zeros</span><span class="p">:</span>
            <span class="n">bigimwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bigimwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
        <span class="n">bigimwt</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">nanmaskarray</span> <span class="o">*</span> <span class="n">interpolate_nan</span>
        <span class="n">wtfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">bigimwt</span><span class="p">)</span>
        <span class="c"># I think this one HAS to be normalized (i.e., the weights can&#39;t be</span>
        <span class="c"># computed with a non-normalized kernel)</span>
        <span class="n">wtfftmult</span> <span class="o">=</span> <span class="n">wtfft</span> <span class="o">*</span> <span class="n">kernfft</span> <span class="o">/</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">wtsm</span> <span class="o">=</span> <span class="n">ifftn</span><span class="p">(</span><span class="n">wtfftmult</span><span class="p">)</span>
        <span class="c"># need to re-zero weights outside of the image (if it is padded, we</span>
        <span class="c"># still don&#39;t weight those regions)</span>
        <span class="n">bigimwt</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">wtsm</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span>
        <span class="c"># curiously, at the floating-point limit, can get slightly negative numbers</span>
        <span class="c"># they break the min_wt=0 &quot;flag&quot; and must therefore be removed</span>
        <span class="n">bigimwt</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigimwt</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fftmult</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="c"># this check should be unnecessary; call it an insanity check</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Encountered NaNs in convolve.  This is disallowed.&quot;</span><span class="p">)</span>

    <span class="c"># restore nans in original image (they were modified inplace earlier)</span>
    <span class="c"># We don&#39;t have to worry about masked arrays - if input was masked, it was</span>
    <span class="c"># copied</span>
    <span class="n">array</span><span class="p">[</span><span class="n">nanmaskarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">kernel</span><span class="p">[</span><span class="n">nanmaskkernel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">return_fft</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fftmult</span>

    <span class="k">if</span> <span class="n">interpolate_nan</span> <span class="ow">or</span> <span class="n">ignore_edge_zeros</span><span class="p">:</span>
        <span class="n">rifft</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifftn</span><span class="p">(</span><span class="n">fftmult</span><span class="p">))</span> <span class="o">/</span> <span class="n">bigimwt</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bigimwt</span><span class="p">):</span>
            <span class="n">rifft</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">&lt;</span> <span class="n">min_wt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="n">min_wt</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">rifft</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rifft</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifftn</span><span class="p">(</span><span class="n">fftmult</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">crop</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">rifft</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rifft</span><span class="o">.</span><span class="n">real</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">


<h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>

<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011-2013, The Astropy Developers.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3+. &nbsp;
    Last built 03 Apr 2013. <br/>
  </p>
</footer>
 <!-- End original user content -->


<br>
<br>
<br>


<style type="text/css">
  .rtd-badge {
    position: fixed;
    display: block;
    bottom: 5px;
    height: 40px;
    text-indent: -9999em;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
    -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
  }
  #version_menu {
    position: fixed;
    display: none;
    bottom: 11px;
    right: 166px;
    list-style-type: none;
    margin: 0;
  }
  .footer_popout:hover #version_menu {
    display: block;
  }
  #version_menu li {
    display: block;
    float: right;
  }
  #version_menu li a {
    display: block;
    padding: 6px 10px 4px 10px;
    margin: 7px 7px 0 0;
    font-weight: bold;
    font-size: 14px;
    height: 20px;
    line-height: 17px;
    text-decoration: none;
    color: #fff;
    background: #8ca1af url(../images/gradient-light.png) bottom left repeat-x;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    box-shadow: 0 1px 1px #465158;
    -moz-box-shadow: 0 1px 1px #465158;
    -webkit-box-shadow: 0 1px 1px #465158;
    text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
  }
  #version_menu li a:hover {
    text-decoration: none;
    background-color: #697983;
    box-shadow: 0 1px 0px #465158;
    -moz-box-shadow: 0 1px 0px #465158;
    -webkit-box-shadow: 0 1px 0px #465158;
  }
  .rtd-badge.rtd {
    background: #3b4449 url(//media.readthedocs.org//images/badge-rtd.png) scroll 0px -46px no-repeat;
    border: 1px solid #282E32;
    width: 41px;
    right: 5px;
  }
  .footer_popout:hover .rtd-badge.rtd {
    background-position: top left;
    width: 160px;
  }
  .rtd-badge.revsys { background: #465158 url(//media.readthedocs.org//images/badge-revsys.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 290px;
    right: 173px;
  }
  .rtd-badge.revsys-inline-sponsored {
    position: inherit;
    margin-left: auto;
    margin-right: 175px;
    margin-bottom: 5px;
    background: #465158 url(//media.readthedocs.org//images/badge-revsys.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 290px;
    right: 173px;
  }
  .rtd-badge.revsys-inline {
    position: inherit;
    margin-left: auto;
    margin-right: 175px;
    margin-bottom: 5px;
    background: #465158 url(//media.readthedocs.org//images/badge-revsys-sm.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 205px;
    right: 173px;
  }

</style>
<div class="rtd_doc_footer">
  <div class="footer_popout">
    <a href="//readthedocs.org/projects/astropy/?fromdocs=astropy" class="rtd-badge rtd"> Brought to you by Read the Docs</a>
    <ul id="version_menu">
      
        <li><a href="/en/latest/">latest</a></li>
      
        <li><a href="/en/add-mpl-to-rtd-pip-req/">add-mpl-to-rtd-pip-req</a></li>
      
        <li><a href="/en/v0.2.1/">v0.2.1</a></li>
      
        <li><a href="/en/v0.2/">v0.2</a></li>
      
        <li><a href="/en/v0.1/">v0.1</a></li>
      
    </ul>
  </div>
</div>
<!-- RTD Analytics Code -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


<!-- User Analytics Code -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-30968842-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



  </body>
</html>